<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/png" href="../peter.png">
<title>Dark Mode Sudoku</title>
<style>
  body {
    margin: 0;
    background: #121212;
    color: #e0e0e0;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .controls {
    margin: 16px;
    display: flex;
    gap: 12px;
    align-items: center;
  }
  .candidate-toggle {
    display: flex;
    justify-content: center;
    margin-top: 16px; /* added to shift the checkbox lower */
    margin-bottom: 16px;
  }
  .controls label,
  .candidate-toggle label {
    display: flex;
    align-items: center;
    gap: 6px;
    background: #1e1e2e;
    border: 1px solid #5a4d7f;
    border-radius: 4px;
    padding: 8px 12px;
    cursor: pointer;
    user-select: none;
  }
  input[type="checkbox"] {
    appearance: none;
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border: 1px solid #5a4d7f;
    border-radius: 3px;
    background: #121212;
    position: relative;
    cursor: pointer;
  }
  input[type="checkbox"]:checked {
    background: #5a4d7f;
  }
  input[type="checkbox"]:checked::after {
    content: '✓';
    position: absolute;
    top: 0;
    left: 2px;
    font-size: 12px;
    color: #e0e0e0;
  }
  .controls > *:not(label) {
    background: #1e1e2e;
    border: 1px solid #5a4d7f;
    border-radius: 4px;
    color: #e0e0e0;
    padding: 8px;
  }
  .board {
    display: grid;
    grid-template-columns: repeat(9, 45px);
    grid-template-rows: repeat(9, 45px);
  }
  .cell {
    position: relative;
    width: 45px;
    height: 45px;
    background: #1a1a1a;
    box-sizing: border-box;
    border: 1px solid #5a4d7f;
    cursor: pointer;
    transition: opacity 0.5s ease;
  }
  .cell.fade-out {
    opacity: 0;
  }
  .cell.border-top { border-top-width: 2px; }
  .cell.border-bottom { border-bottom-width: 2px; }
  .cell.border-left { border-left-width: 2px; }
  .cell.border-right { border-right-width: 2px; }
  .cell.fixed .candidates { visibility: hidden; }
  .cell .value {
    position: absolute; inset: 0;
    display: flex; align-items: center; justify-content: center;
    font-size: 1.2em; pointer-events: none;
    opacity: 1;
    transition: opacity 0.2s ease;
  }
  .cell .value.fade-out {
    opacity: 0;
  }
  .cell .candidates {
    position: absolute; inset: 2px;
    display: grid;
    grid-template-columns: repeat(3,1fr);
    grid-template-rows: repeat(3,1fr);
    font-size: 0.6em; color: #888;
    visibility: hidden;
  }
  .cell .candidate {
    display: flex; align-items: center; justify-content: center;
    pointer-events: none;
  }
  .cell.highlight   { background: #2e1e4f; }
  .cell.duplicate   { background: #4f1e1e; }
  .cell.mistake     { outline: 2px solid #ff3366; }
  .cell.conflict    { outline: 2px dashed #ff9933; }
  .cell .candidate.highlight { color: #ff3366; }
  .cell.selected {
    background: #3b3b5e;
    border: 2px solid #ffffff;
    box-shadow: 0 0 8px 2px rgba(255,255,255,0.5);
    position: relative; /* ensures z-index works */
    z-index: 100;
  }
  /* New rule: when candidate mode is enabled, selected cell gets a faded white border */
  .cell.selected.candidate-selected {
    border: 2px solid rgba(255,255,255,0.5);
    box-shadow: none;
  }
  /* update associated cell highlighting: add animation */
  .cell.associated {
    background: #1f1f33;
    animation: associatedFlash 0.3s ease;
  }
  /* new animation keyframes for neighboring cell highlighting */
  @keyframes associatedFlash {
    0% { background: #1a1a1a; }
    50% { background: #1f1f33; }
    100% { background: #1f1f33; }
  }

  .pad-container {
    margin-top: 12px;
    display: flex;
    align-items: flex-start;
    gap: 16px;
    min-height: 55px; /* added to reserve space when red circles fade out */
  }
  .number-pad {
    display: flex;
    gap: 8px;
    flex-wrap: nowrap;
  }
  .pad-item {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .pad-item button {
    width: 40px; height: 45px;
    background: #2a2a3a; border: 1px solid #5a4d7f;
    border-radius: 4px; color: #e0e0e0; cursor: pointer;
  }
  .pad-item button.clear {
    background: #3a2a2a;
  }
  /* ← UPDATED: force a 3×3 grid of circles under each number */
  .count-indicator {
    display: grid;
    grid-template-columns: repeat(3, 6px);
    grid-auto-rows: 6px;
    gap: 2px;
    margin-top: 4px;
    /* optional: ensure it’s exactly 3 columns wide */
    width: calc(3 * 6px + 2 * 2px);
    transition: opacity 0.2s ease;
    opacity: 1;
    height: 22px;          /* fixed height to reserve space */
    flex-shrink: 0;        /* prevent shrinking if in flex container */
  }
  .count-indicator.fade-out {
    opacity: 0;
  }
  .count-indicator .circle {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #ff3366;
  }

  /* New CSS for button glowing */
  @keyframes pulse {
    0% { box-shadow: 0 0 5px #fff; }
    50% { box-shadow: 0 0 20px #fff; }
    100% { box-shadow: 0 0 5px #fff; }
  }
  button#newGame.glow {
    animation: pulse 1s infinite;
  }
  .cell.mistake, .cell.conflict {
    z-index: 10; /* ensure this cell is above adjacent cells */
    position: relative;
    outline-offset: 2px; /* push the outline outward */
  }

  /* Updated style for control instructions label */
  .controls-label {
    font-size: 0.8em;
    color: #aaa;
    background: #1e1e2e;
    padding: 10px 15px;
    border-radius: 5px;
    text-align: left;
    max-width: 400px;
    margin-top: 12px;
  }
  .controls-label ul {
    list-style: disc inside;
    padding-left: 20px;
    margin: 5px 0 0 0;
  }
  .controls-label li {
    margin-bottom: 5px;
  }

  /* New rule: Make original clue numbers slightly darker */
  .cell.fixed .value {
    color: #b0b0b0;
  }
  /* New rule: Make user-input numbers more white */
  .cell:not(.fixed) .value {
    color: #ffffff;
  }
  .cell.duplicate {
    background: #4f1e1e;
    animation: duplicateFlash 0.3s ease;
  }
  @keyframes duplicateFlash {
    0% { background: #1f1f33; }
    100% { background: #4f1e1e; }
  }

  /* Remove or ignore .board-timer-container styles */
  /* New container to center the puzzle */
  .board-container {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    margin: 0 auto 16px auto;
  }
  /* New row container to hold timer and copy button inline */
  .info-col {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
  }
  /* Remove absolute positioning from timer */
  .timer {
    position: static;
    background: #1e1e2e;
    color: #e0e0e0;
    border: 1px solid #5a4d7f;
    border-radius: 4px;
    padding: 8px 12px;
    font-size: 1.2em;
    font-family: sans-serif;
    width: 60px; /* fixed width */
    text-align: center;
  }

  button#copyPuzzle {
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 6px;
    border-radius: 4px;
  }
  button#copyPuzzle svg {
    width: 20px;
    height: 20px;
    fill: #e0e0e0;
  }
  button#copyPuzzle:hover {
    background: rgba(0, 0, 0, 0.1);
  }
</style>
</head>
<body>
  <div class="controls">
    <label>
      Difficulty:
      <!-- Changed slider to have 5 values -->
      <input type="range" id="difficulty" min="1" max="5" value="1">
    </label>
    <button id="newGame">New Game</button>
    <!-- Removed copy puzzle button from here -->
    <label><input type="checkbox" id="showMistakes"> Show Mistakes</label>
    <label><input type="checkbox" id="showConflicts"> Show Conflicts</label>
  </div>

  <!-- Updated board container: board on left, info-col on right -->
  <div class="board-container">
    <!-- Moved board here -->
    <div class="board" id="board"></div>
    <div class="info-col">
      <div class="timer" id="timer">00:00</div>
      <!-- Copy button remains unchanged -->
      <button id="copyPuzzle" title="Copy Puzzle">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M16 1H4c-1.11 0-2 .89-2 2v14h2V3h12V1zm3 4H8
                   c-1.11 0-2 .89-2 2v14c0 1.11.89 2 2 2h11
                   c1.11 0 2-.89 2-2V7c0-1.11-.89-2-2-2zm0 16H8V7h11v14z"/>
        </svg>
      </button>
    </div>
  </div>

  <div class="pad-container">
    <div class="number-pad" id="pad"></div>
  </div>
  
  <div class="candidate-toggle">
    <label><input type="checkbox" id="candidateMode"> Candidate Mode</label>
  </div>

  <!-- Updated controls instructions label -->
  <div class="controls-label">
    <strong>Keyboard Controls</strong>
    <ul>
      <li>Press 1-9 to enter numbers</li>
      <li>Press C or Space to toggle Candidate Mode</li>
      <li>Press 0 or Backspace to clear entry</li>
      <li>Click a cell to select</li>
    </ul>
  </div>
  
  <script>
  (() => {
  const boardEl = document.getElementById('board');
  const padEl = document.getElementById('pad');
  const newGameBtn = document.getElementById('newGame');
  const diffEl = document.getElementById('difficulty');
  const showMistakesEl = document.getElementById('showMistakes');
  const showConflictsEl = document.getElementById('showConflicts');
  const candidateModeEl = document.getElementById('candidateMode');

  let solution = [], puzzle = [], candidates = [];
  let selected = null;
  let clues = [];  // <-- NEW: track original clues
  const indicatorEls = [];
  let gameCompleted = false;
  let hasGameStarted = false; // new variable to track if a game has begun
  let timerStarted = false; // new variable to track if the timer has started

  // NEW: Global puzzle queue for difficulties 1-5
  const puzzleQueue = { 1: [], 2: [], 3: [], 4: [], 5: [] };

  // NEW: Extracted puzzle generation logic returning {puzzle, solution, clues}
  async function generatePuzzleData(diff) {
    const cluesArray = [56, 44, 35, 26, 17];
    const desiredClues = cluesArray[diff - 1];
    let sol = Array(81).fill(0);
    const rows = Array.from({ length: 9 }, () => new Set());
    const cols = Array.from({ length: 9 }, () => new Set());
    const boxes = Array.from({ length: 9 }, () => new Set());
    function fill(i = 0) {
      if (i === 81) return true;
      const r = Math.floor(i / 9), c = i % 9;
      const b = Math.floor(r / 3) * 3 + Math.floor(c / 3);
      const nums = shuffle([1,2,3,4,5,6,7,8,9]);
      for (const n of nums) {
        if (!rows[r].has(n) && !cols[c].has(n) && !boxes[b].has(n)) {
          rows[r].add(n);
          cols[c].add(n);
          boxes[b].add(n);
          sol[i] = n;
          if (fill(i + 1)) return true;
          rows[r].delete(n);
          cols[c].delete(n);
          boxes[b].delete(n);
        }
      }
      return false;
    }
    fill();
    
    let pus = sol.slice();
    const indices = shuffle([...Array(81).keys()]);
    for (const i of indices) {
      if (pus.filter(v => v !== null).length <= desiredClues) break;
      const backup = pus[i];
      pus[i] = null;
      if (!hasUniqueSolution(pus)) {
        pus[i] = backup;
      }
      await new Promise(resolve => setTimeout(resolve, 0));
    }
    const clueFlags = pus.map(v => v !== null);
    console.log("Background generated puzzle for diff " + diff + " with " + pus.filter(v => v !== null).length + " clues.");
    return { puzzle: pus, solution: sol, clues: clueFlags };
  }

  // NEW: Background queue fill function ensuring 2 puzzles per difficulty
  function fillQueue() {
    for (let d = 1; d <= 5; d++) {
      if (puzzleQueue[d].length < 4) {
        // Schedule generation in the background
        setTimeout(() => {
          generatePuzzleData(d).then(result => {
            puzzleQueue[d].push(result);
          });
        }, 0);
      }
    }
  }

  // Modified generate() to serve queued puzzle if available; otherwise generate immediately.
  async function generate() {
    // Immediately unselect any selected cell and trigger fade-out
    selected = null;
    render();
    const valueEls = document.querySelectorAll('.cell .value');
    const indicatorContainers = document.querySelectorAll('.count-indicator');
    if (valueEls.length) {
      valueEls.forEach(el => el.classList.add('fade-out'));
    }
    if (indicatorContainers.length) {
      indicatorContainers.forEach(el => el.classList.add('fade-out'));
    }
    await new Promise(resolve => setTimeout(resolve, 100)); // reduced delay

    // NEW: Use queued puzzle if available for the current diff.
    const diff = Number(diffEl.value);
    let puzzleData;
    if (puzzleQueue[diff].length > 0) {
      puzzleData = puzzleQueue[diff].shift();
    } else {
      puzzleData = await generatePuzzleData(diff);
    }
    // Set global puzzle state
    solution = puzzleData.solution;
    puzzle = puzzleData.puzzle;
    clues = puzzleData.clues;
    // Instead of marking game as started, reset timer control:
    timerStarted = false; // reset timer; it hasn't started yet for the new puzzle
    
    render();
    await new Promise(resolve => setTimeout(resolve, 10));
    valueEls.forEach(el => el.classList.remove('fade-out'));
    indicatorContainers.forEach(el => el.classList.remove('fade-out'));

    // NEW: Refill the background queue for all difficulties.
    fillQueue();
  }

  function buildBoard() {
    boardEl.innerHTML = '';
    candidates = Array(81).fill().map(() => new Set());
    for (let i = 0; i < 81; i++) {
      const r = Math.floor(i/9), c = i % 9;
      const cell = document.createElement('div');
      cell.className = 'cell';
      if (r % 3 === 0) cell.classList.add('border-top');
      if (r % 3 === 2) cell.classList.add('border-bottom');
      if (c % 3 === 0) cell.classList.add('border-left');
      if (c % 3 === 2) cell.classList.add('border-right');
      cell.dataset.index = i;
      cell.addEventListener('click', () => selectCell(i));

      const valEl = document.createElement('div');
      valEl.className = 'value';
      cell.appendChild(valEl);

      const candEl = document.createElement('div');
      candEl.className = 'candidates';
      for (let n = 1; n <= 9; n++) {
        const cd = document.createElement('div');
        cd.className = 'candidate';
        cd.textContent = n;
        candEl.appendChild(cd);
      }
      cell.appendChild(candEl);

      boardEl.appendChild(cell);
    }
  }

  function buildPad() {
    padEl.innerHTML = '';
    indicatorEls.length = 0;
    for (let n = 1; n <= 9; n++) {
      const item = document.createElement('div');
      item.className = 'pad-item';

      const btn = document.createElement('button');
      btn.textContent = n;
      btn.addEventListener('click', () => onPadClick(n));
      item.appendChild(btn);

      const ind = document.createElement('div');
      ind.className = 'count-indicator';
      item.appendChild(ind);

      padEl.appendChild(item);
      indicatorEls[n] = ind;
    }
    const clearItem = document.createElement('div');
    clearItem.className = 'pad-item';
    const clearBtn = document.createElement('button');
    clearBtn.textContent = 'C';
    clearBtn.className = 'clear';
    clearBtn.addEventListener('click', () => onPadClick(0));
    clearItem.appendChild(clearBtn);
    // no indicator for clear
    padEl.appendChild(clearItem);
  }

  function selectCell(idx) {
    selected = idx;
    render();
  }

  function onPadClick(n) {
    if (selected === null) return;
    // Start the timer on the very first guess or candidate placement.
    if (!timerStarted) {
      startTimer();
      timerStarted = true;
    }
    // Mark game as started on first valid input.
    if (!hasGameStarted) {
      hasGameStarted = true;
    }
    // Only block non-clear actions if a value is already present
    if (n !== 0 && puzzle[selected] !== null) return;

    // Always treat n===0 as “clear value”
    if (n === 0) {
      setValue(selected, n);
    }
    else if (candidateModeEl.checked) {
      setCandidate(selected, n);
    }
    else {
      setValue(selected, n);
    }
    render();
  }

  function setValue(i, n) {
    puzzle[i] = n || null;
    candidates[i].clear();
    if (n) removeCandidatesPeers(i, n);
  }

  function setCandidate(i, n) {
    if (!n) return;
    candidates[i].has(n) ? candidates[i].delete(n) : candidates[i].add(n);
  }

  function removeCandidatesPeers(i, n) {
    const r = Math.floor(i/9), c = i % 9;
    const br = r - r % 3, bc = c - c % 3;
    for (let j = 0; j < 9; j++) {
      candidates[r*9 + j].delete(n);
      candidates[j*9 + c].delete(n);
    }
    for (let dr = 0; dr < 3; dr++) for (let dc = 0; dc < 3; dc++) {
      candidates[(br+dr)*9 + bc+dc].delete(n);
    }
  }

  function render() {
    const cells = boardEl.children;
    for (let i = 0; i < 81; i++) {
          const cell = cells[i];
          const v = puzzle[i];
          cell.querySelector('.value').textContent = v || '';
          // Modified: use clues[i] instead of !!v to toggle original given style
          cell.classList.toggle('fixed', clues[i]);
          const candEls = cell.querySelectorAll('.candidate');
          candEls.forEach((cEl, idx) => {
              cEl.style.visibility = candidates[i].has(idx+1) ? 'visible' : 'hidden';
              cEl.classList.toggle('highlight',
                  selected !== null &&
                  idx+1 === (puzzle[selected] || null)
              );
          });
          cell.classList.remove('highlight','duplicate','mistake','conflict');
          cell.classList.remove('selected','associated');
      }
      if (selected !== null) {
          const r = Math.floor(selected/9), c = selected % 9;
          const br = r - r % 3, bc = c - c % 3;
          // mark associated cells for row, column, and block
          for (let j = 0; j < 9; j++) {
              if (r * 9 + j !== selected) cells[r * 9 + j].classList.add('associated');
              if (j * 9 + c !== selected) cells[j * 9 + c].classList.add('associated');
          }
          for (let dr = 0; dr < 3; dr++) {
              for (let dc = 0; dc < 3; dc++) {
                  const idx = (br + dr) * 9 + bc + dc;
                  if (idx !== selected) cells[idx].classList.add('associated');
              }
          }
          // New: duplicate highlight for matching values
          if (puzzle[selected]) {
            for (let k = 0; k < 81; k++) {
              if (puzzle[k] === puzzle[selected] && k !== selected)
                cells[k].classList.add('duplicate');
            }
          }
          cells[selected].classList.remove('associated');
          cells[selected].classList.add('selected');
          // If candidate mode is enabled, add candidate-selected extra border style.
          if (candidateModeEl.checked) {
              cells[selected].classList.add('candidate-selected');
          } else {
              cells[selected].classList.remove('candidate-selected');
          }
      }
      updateIndicators();
      
      // NEW: Always highlight mistakes and conflicts regardless of cell selection.
      if (showMistakesEl.checked) checkMistakes();
      if (showConflictsEl.checked) checkConflicts();
      
      if (isSolved() && hasGameStarted && !gameCompleted) { // added hasGameStarted check
        gameCompleted = true;
        newGameBtn.classList.add("glow");
        startConfetti();
      } else if (!isSolved()) {
        newGameBtn.classList.remove("glow");
      }
    }

    function checkMistakes() {
      for (let i = 0; i < 81; i++) {
        const v = puzzle[i];
        if (v && v !== solution[i]) {
          boardEl.children[i].classList.add('mistake');
        }
      }
    }

    function checkConflicts() {
      for (let i = 0; i < 81; i++) {
        const v = puzzle[i];
        if (!v) continue;
        const r = Math.floor(i/9), c = i % 9;
        const br = r - r % 3, bc = c - c % 3;
        for (let j = 0; j < 9; j++) {
          if (j !== c && puzzle[r*9 + j] === v) boardEl.children[i].classList.add('conflict');
          if (j !== r && puzzle[j*9 + c] === v) boardEl.children[i].classList.add('conflict');
        }
        for (let dr = 0; dr < 3; dr++) for (let dc = 0; dc < 3; dc++) {
          const idx = (br+dr)*9 + bc+dc;
          if (idx !== i && puzzle[idx] === v) boardEl.children[i].classList.add('conflict');
        }
      }
    }

    function updateIndicators() {
      // count how many times each number appears
      const counts = Array(10).fill(0);
      puzzle.forEach(v => { if (v) counts[v]++; });
      for (let n = 1; n <= 9; n++) {
        const rem = 9 - counts[n];
        const ind = indicatorEls[n];
        ind.innerHTML = '';
        for (let i = 0; i < rem; i++) {
          const dot = document.createElement('div');
          dot.className = 'circle';
          ind.appendChild(dot);
        }
      }
    }

    // Verifier helper functions:
    function isValid(board, row, col, num) {
      for (let j = 0; j < 9; j++) {
        if (board[row * 9 + j] === num) return false;
        if (board[j * 9 + col] === num) return false;
      }
      const br = Math.floor(row / 3) * 3, bc = Math.floor(col / 3) * 3;
      for (let r = br; r < br + 3; r++) {
        for (let c = bc; c < bc + 3; c++) {
          if (board[r * 9 + c] === num) return false;
        }
      }
      return true;
    }
    
    function countSolutions(board) {
      let solutionCount = 0;
      function solve() {
        const idx = board.findIndex(v => v === null);
        if (idx === -1) {
          solutionCount++;
          return;
        }
        const row = Math.floor(idx / 9), col = idx % 9;
        for (let num = 1; num <= 9; num++) {
          if (isValid(board, row, col, num)) {
            board[idx] = num;
            solve();
            if (solutionCount > 1) return;
            board[idx] = null;
          }
        }
      }
      solve();
      return solutionCount;
    }
    
    function hasUniqueSolution(board) {
      const boardCopy = board.slice();
      return countSolutions(boardCopy) === 1;
    }
    
    // Updated generate() with verifier and counter update.
    async function generate() {
      // Immediately unselect any selected cell and trigger fade out
      selected = null;
      render();
      const valueEls = document.querySelectorAll('.cell .value');
      const indicatorContainers = document.querySelectorAll('.count-indicator');
      if (valueEls.length) {
          valueEls.forEach(el => el.classList.add('fade-out'));
      }
      if (indicatorContainers.length) {
          indicatorContainers.forEach(el => el.classList.add('fade-out'));
      }
      // Reduced delay: start generating a new puzzle almost immediately
      await new Promise(resolve => setTimeout(resolve, 100)); // was 500

      // Optionally remove the following block or also reduce its timing
      const currentValues = document.querySelectorAll('.cell .value');
      if (currentValues.length) {
        currentValues.forEach(el => el.classList.add('fade-out'));
        await new Promise(resolve => setTimeout(resolve, 100)); // was 500
      }
      
      // NEW: Use queued puzzle if available for the current diff.
      const diff = Number(diffEl.value);
      let puzzleData;
      if (puzzleQueue[diff].length > 0) {
        puzzleData = puzzleQueue[diff].shift();
      } else {
        puzzleData = await generatePuzzleData(diff);
      }
      // Set global puzzle state
      solution = puzzleData.solution;
      puzzle = puzzleData.puzzle;
      clues = puzzleData.clues;
      // Instead of marking game as started, reset timer control:
      timerStarted = false; // reset timer; it hasn't started yet for the new puzzle
      
      // Render new board and then fade in numbers and indicators
      render();
      await new Promise(resolve => setTimeout(resolve, 10)); // minimal delay before fade in
      valueEls.forEach(el => el.classList.remove('fade-out'));
      indicatorContainers.forEach(el => el.classList.remove('fade-out'));

      // NEW: Refill the background queue for all difficulties.
      fillQueue();
    }

    let timerInterval;
    let startTime;

    function startTimer() {
      startTime = Date.now();
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const minutes = Math.floor(elapsed / 60000).toString().padStart(2, '0');
        const seconds = Math.floor((elapsed % 60000) / 1000).toString().padStart(2, '0');
        document.getElementById('timer').textContent = `${minutes}:${seconds}`;
      }, 1000);
    }

    function resetTimer() {
      clearInterval(timerInterval);
      document.getElementById('timer').textContent = '00:00';
    }

    // Reset timer when a new game is started
    newGameBtn.addEventListener('click', () => {
      resetTimer();
    });

    // New: copy puzzle functionality without text changes.
    const copyPuzzleBtn = document.getElementById('copyPuzzle');
    copyPuzzleBtn.addEventListener('click', () => {
      const puzzleText = puzzle.map(cell => cell ? cell : '.').join('');
      navigator.clipboard.writeText(puzzleText)
        .catch(err => console.error('Failed to copy puzzle: ', err));
    });

    function shuffle(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function isSolved() {
      return puzzle.every((v, i) => v !== null && v === solution[i]);
    }

    function startConfetti() {
      // Create canvas for confetti animation
      const canvas = document.createElement('canvas');
      canvas.id = 'confettiCanvas';
      canvas.style.position = 'fixed';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.pointerEvents = 'none';
      // Change z-index to place canvas behind all elements
      canvas.style.zIndex = '-1';
      document.body.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      const particles = [];
      const numParticles = 150;
      const colors = ['#FFC107', '#FF5722', '#4CAF50', '#2196F3', '#9C27B0'];
      
      for (let i = 0; i < numParticles; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height - canvas.height,
          // Smaller particles: reduced radius range
          r: Math.random() * 2 + 1,
          d: Math.random() * numParticles,
          color: colors[Math.floor(Math.random() * colors.length)],
          tilt: Math.floor(Math.random() * 10) - 10,
          tiltAngleIncrement: Math.random() * 0.07 + 0.05,
          tiltAngle: 0
        });
      }
      
      let animationComplete = false;
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => {
          p.tiltAngle += p.tiltAngleIncrement;
          p.y += (Math.cos(p.d) + 3 + p.r/2) / 2;
          p.tilt = Math.sin(p.tiltAngle) * 15;
          ctx.beginPath();
          ctx.lineWidth = p.r;
          ctx.strokeStyle = p.color;
          ctx.moveTo(p.x + p.tilt + p.r/2, p.y);
          ctx.lineTo(p.x + p.tilt, p.y + p.tilt + p.r/2);
          ctx.stroke();
        });
        if (!animationComplete) requestAnimationFrame(draw);
      }
      draw();
      // Remove confetti after 5 seconds
      setTimeout(() => {
        animationComplete = true;
        canvas.remove();
      }, 5000);
    }

    buildBoard();
    buildPad();
    newGameBtn.addEventListener('click', () => {
      gameCompleted = false;
      hasGameStarted = false;  // Reset game start flag to prevent celebration on new game
      newGameBtn.classList.remove("glow");
      generate();
    });
    diffEl.addEventListener('input', generate);
    showMistakesEl.addEventListener('change', render);
    showConflictsEl.addEventListener('change', render);
    candidateModeEl.addEventListener('change', render);
    
    // ← new: keyboard support for 1–9, 0/backspace = clear
    document.addEventListener('keydown', e => {
      // ignore if focus is in an input (so sliders, checkboxes still work)
      if (e.target.tagName === 'INPUT') return;

      // Toggle candidate mode on "C" key or space bar
      if (e.key.toLowerCase() === 'c' || e.key === ' ') {
        candidateModeEl.checked = !candidateModeEl.checked;
        render();
        e.preventDefault();
      }
      else if (e.key >= '1' && e.key <= '9') {
        onPadClick(Number(e.key));
        e.preventDefault();
      }
      else if (e.key === '0' || e.key === 'Backspace') {
        onPadClick(0);
        e.preventDefault();
      }
    });
    
    // Add background click listener to deselect cells
    document.addEventListener('click', e => {
      if (
        e.target.closest('#board') ||
        e.target.closest('.controls') ||
        e.target.closest('.pad-container') ||
        e.target.closest('.candidate-toggle')
      ) {
        return;
      }
      selected = null;
      render();
    });
    
    // Start by generating an immediate puzzle for the selected difficulty.
    generate();
    
    // Initially fill queue for all difficulties.
    fillQueue();
  })();
  </script>
</body>
</html>
